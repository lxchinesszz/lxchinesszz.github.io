{"meta":{"title":"程序猿升级课","subtitle":null,"description":"一个关注于程序猿技术提升的博客","author":"liuxin","url":"http://lxchinesszz.gitee.io/chinesszz"},"pages":[],"posts":[{"title":"Netty组件介绍","slug":"Netty组件介绍","date":"2018-04-11T09:39:03.000Z","updated":"2018-04-11T09:59:38.762Z","comments":true,"path":"2018/04/11/Netty组件介绍/","link":"","permalink":"http://lxchinesszz.gitee.io/chinesszz/2018/04/11/Netty组件介绍/","excerpt":"","text":"在学习Netty之前，建议首先学习一个NIO，对关键的NIO组件有一个清醒认识 Buffer Selector 总览 Bootstrap or ServerBootstrap EventLoop EventLoopGroup ChannelPipeline Future or ChannelFuture ChannelInitializer ChannelHandler ByteToMessageDecoder MessageToByteEncoder ChannelPipline Channel ChannelHandlerContext ServerBootstrap一个Netty应用通常由一个Bootstrap开始，它主要作用是配置整个Netty程序，串联起各个组件。 option() 针对boss线程,用于连接 childOption() 针对work线程,用于处理数据 BootStrap123456789101112131415161718192021222324252627EventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group).channel(NioSocketChannel.class) .remoteAddress(new InetSocketAddress(host, port)) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); pipeline.addLast(new SimpleChannelInboundHandler&lt;ByteBuf&gt;() &#123; //在连接的时候将数据发送给 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; ctx.channel().writeAndFlush(request); &#125; //接受信息 @Override protected void messageReceived(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) throws Exception &#123; result = new byte[byteBuf.readableBytes()]; byteBuf.readBytes(result); &#125; &#125;); &#125; &#125;); ChannelFuture future = bootstrap.connect().sync(); future.addListener(ChannelFutureListener.CLOSE).sync(); EventLoop一个EventLoop可以为多个Channel服务。 EventLoopGroup会包含多个EventLoop ChannelPipeline,ChannelHandler从PipeLine这个单词中可以看出来，是一个管道，处理连接。我们的业务代码handler一般都是放在这个管道中的 那么疑问来了，这个管道中的处理顺序是什么样呢？ 1234ChannelPipeline cp = channel.pipeline(); cp.addLast(\"encoder\", new HttpResponseEncoder());//1.负责输出cp.addLast(\"decoder\", new HttpRequestDecoder());//2.负责把客户端的数据解码cp.addLast(\"handler\", new HttpDispatchServerHandler());//3.自定义的业务处理器 按照我们执行顺序肯定不是根据添加顺序来处理的，应该是:2,把客户端的数据解码-&gt;3.对解码数据处理-&gt;1.加密返回给客户端。 那么 Netty 是怎么处理的呢？ ChannelHandler有两个子类ChannelInboundHandler和ChannelOutboundHandler，这两个类对应了两个数据流向，如果数据是从外部流入我们的应用程序，我们就看做是inbound，相反便是outbound ChannelInitializer顾名思义,这个就是channel初始化的容器，在这个里面设置处理器 123456789101112131415161718192021222324ServerBootstrap bootstrap = new ServerBootstrap(); bossGroup = new NioEventLoopGroup();//负责绑定channel到selector workerGroup = new NioEventLoopGroup();//负责从selector中读取事件 bootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class) .localAddress(6969).option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000) .childOption(ChannelOption.SO_KEEPALIVE, true).childHandler(new ChannelInitializer&lt;Channel&gt;() &#123; @Override protected void initChannel(Channel channel) throws Exception &#123; ChannelPipeline cp = channel.pipeline(); cp.addLast(\"idleStateHandler\", new IdleStateHandler(5, 5, 5, TimeUnit.SECONDS)); cp.addLast(\"decoder\", new HttpRequestDecoder()); cp.addLast(\"encoder\", new HttpResponseEncoder()); cp.addLast(\"aggregator\", new HttpObjectAggregator(1048576)); cp.addLast(\"deflater\", new HttpContentCompressor()); cp.addLast(\"handler\", new HttpDispatchServerHandler()); cp.addLast(\"out\", new AcceptorIdleStateTrigger()); &#125; &#125;).option(ChannelOption.SO_BACKLOG, 128); try &#123; channel = bootstrap.bind().awaitUninterruptibly().channel(); showBanner(6969); &#125; catch (Exception ie) &#123; throw new RuntimeException(ie); &#125; ###ChannelFuture Netty中的连接都可以是异步的，但是也可以设置为非异步 ChannelFutureChannel 每个操作都会返回一个 ChannelFutrue 因为是异步的，所以我们为每个异步的结果，添加一个监听,比如: 12345678# 当完成关闭动作，就执行监听器内容f = f.channel().closeFuture().await(); f.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) throws Exception &#123; System.out.println(&quot;success complete!!ok!!&quot;); &#125; &#125;); 当然还有一种方法， 就是await()，此返回会等待上一个操作完成，在进行下一个操作。但是推荐使用第一种。 ByteToMessageDecoder解密器，可以自定义协议，通过集成改接口，重写 decode 方法把二进制，转换为我们系统可以处理的对象 12345678910111213141516171819202122import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.ByteToMessageDecoder;import java.util.List;/** * 把字节转换为int * 继承抽象类ByteToMessageDecoder实现解码器 */public class ByteToIntegerDecoder extends ByteToMessageDecoder &#123; @Override public void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123; if (in.readableBytes() &gt;= 4) &#123; // Check if there are at least 4 bytes readable int n = in.readInt(); System.err.println(&quot;ByteToIntegerDecoder decode msg is &quot; + n); out.add(n); //Read integer from inbound ByteBuf, add to the List of decodec messages &#125; &#125;&#125; 编码器将我们系统处理完的信息，编码成，二进制，传出，给调用者 123456789101112import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.MessageToByteEncoder;public class IntegerToByteEncoder extends MessageToByteEncoder&lt;Integer&gt; &#123; @Override public void encode(ChannelHandlerContext ctx, Integer msg, ByteBuf out) throws Exception &#123; System.err.println(&quot;IntegerToByteEncoder encode msg is &quot; + msg); out.writeInt(msg); &#125;&#125; 解码后的数据怎么使用对于加密后的数据，可以直接强制转换为我们解码的对象 123456789public class BusinessHandler extends ChannelInboundHandlerAdapter &#123; private Logger logger = LoggerFactory.getLogger(BusinessHandler.class); @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; //因为我们的解码其中指定是Int类型，所以我们就可以，强制转换为Int，这里为了好理解，假如我们的解码器，中是转换了Person，那么在我们的处理器中就，可以强制换换为Person Person person = (Person) msg; logger.info(&quot;BusinessHandler read msg from client :&quot; + person); &#125; ChannelPipline 管道 管道中包括(ChannleInBoundHandler)入栈的和(ChannelOutBoundHandler)出栈的当连接发生,由ChannelPipline协调将消息给ChannelHandler处理 当一个ChannelHandler被绑定在了多个ChannelPipeline实例上,为了线程安全会报错.要使用@Sharable注解 Channel 消息的传载实体ChannelHandlerContext ChannelHandlerContext将Channel和ChannelHandler做一个关联因为一个Channel可能与多个ChannelHandler绑定 注意ChannelHandler与下一个ChannelHandler…的交互并不是他们直接产生的,而是有ChannelHandlerContext调用的 从中学习到一个编程技巧,就是当一个实体与多个处理器产生关系的时候,可以定义一个上下文,用来管理关系","categories":[{"name":"Netty","slug":"Netty","permalink":"http://lxchinesszz.gitee.io/chinesszz/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://lxchinesszz.gitee.io/chinesszz/tags/Netty/"}],"keywords":[{"name":"Netty","slug":"Netty","permalink":"http://lxchinesszz.gitee.io/chinesszz/categories/Netty/"}]},{"title":"SpringBoot原生定时任务解析","slug":"SpringBoot原生定时任务解析","date":"2018-04-11T09:35:09.853Z","updated":"2018-04-11T09:35:09.854Z","comments":true,"path":"2018/04/11/SpringBoot原生定时任务解析/","link":"","permalink":"http://lxchinesszz.gitee.io/chinesszz/2018/04/11/SpringBoot原生定时任务解析/","excerpt":"","text":"#SpringBoot原生定时任务，不需要引入任何依赖 ==只要了解，几个注解就可以使用== 1.在启动类上加入@EnableScheduling标签 2.在定时任务方法上加入@Schedule(fixedDelay=5000) 3.就是如此简单，简单的不可想象 123456789101112131415161718192021222324package zebra.shjf;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication@EnableSchedulingpublic class TestQuartzApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TestQuartzApplication.class, args); &#125;&#125;@Componentpublic class ScheduledTasks&#123; @Scheduled(fixedDelay = 5000) public void execute() &#123; System.out.println(&quot;当前时间：&quot; + new Date()); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://lxchinesszz.gitee.io/chinesszz/categories/Spring-Boot/"}],"tags":[{"name":"Spring定时器","slug":"Spring定时器","permalink":"http://lxchinesszz.gitee.io/chinesszz/tags/Spring定时器/"}],"keywords":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://lxchinesszz.gitee.io/chinesszz/categories/Spring-Boot/"}]},{"title":"Spring整合Quartz2.1.1(执行中，得到application上下文，执行bean方法)","slug":"Spring整合Quartz2.1.1(执行中，得到application上下文，执行bean方法)","date":"2018-04-11T09:35:06.704Z","updated":"2018-04-11T09:35:06.704Z","comments":true,"path":"2018/04/11/Spring整合Quartz2.1.1(执行中，得到application上下文，执行bean方法)/","link":"","permalink":"http://lxchinesszz.gitee.io/chinesszz/2018/04/11/Spring整合Quartz2.1.1(执行中，得到application上下文，执行bean方法)/","excerpt":"","text":"==前文==，Quartz中迭代后，变化很大，让我走了很多的误区，这里简单解释一点，希望大家可以跳过误区，建议大家从下往上读（希望对大家有点帮助），我是一只爱分享的小菜鸟 JobDetail和Trigger和Schedule都是接口，统统不能new 1.如果只是执行一些自定义的类，其实使用SpringBoot的自带的任务就可以完成，简单的不能想象。这个可以看-&gt;我的另一篇SpringBoot原生定时任务解析。2.如果要是要动态的执行一些有Spring管理的bean，可能要稍微费点功夫了，网上有很多的教程，那部分都是xml形式配置的，本人菜鸟一枚（十分迷惑），十分不喜欢xml配置，看着眼花，当程序读取的时候还是要解析java对象来执行的，那么为何不直接配置成配置类呢？这个问题先方下，以后会详细解释如何使用Spring Boot配置类。开始代码展示1234567891011121314151617181920212223242526 //job是一个接口，当定时任务执行的时候，就要运行这个方法，那么可以推测 JobExecutionContext这个对象中包含了我们可能使用的关于这个定时任务的所有细节，请看代码public interface Job &#123; void execute(JobExecutionContext var1) throws JobExecutionException;&#125;/** * Created by liuxin on 16/12/21. * 方案1：反射执行类和执行方法（不解析，没有用，刚开始走了误区，自己反射方法执行，大家尽量不要用） * 方案2：读取bean（这个才是重点） */public class ScheduledTasks implements Job &#123; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; System.out.println(&quot;------进入定时方法区域-------&quot;); try &#123; ConfigurableApplicationContext cac = (ConfigurableApplicationContext) jobExecutionContext.getJobDetail().getJobDataMap().get(&quot;ConfigurableApplicationContext&quot;); HelloService helloService = (HelloService) cac.getBean(&quot;helloService&quot;); helloService.hh(); &#125; catch (Exception e) &#123; &#125; &#125;&#125; 上面的代码中看到这个JobExecutionContext可以得到JobDetail，而这个JobDetail对象是我们自己创建的用来详细介绍我们定时任务的，也就是我们要执行的方法的详细在这个里存放，123jobDetail.getJobDataMap().put(&quot;ConfigurableApplicationContext&quot;,cac);这个是我们在main方法中测试时候，提前放进去，的在执行execute方法时候，取到的上下文对象，用来得到bean的这么说是不是很清楚了？接着看代码 测试的bean对象1234567@Servicepublic class HelloService &#123; static int i=0; public void hh()&#123; System.out.println(++i); &#125;&#125; 为了证明这个bean在上下文中，我们打印一下，上下文中的所有的bean 123456789101112131415161718192021222324252627282930313233@SpringBootApplicationpublic class TestQuartzApplication &#123; public static void main(String[] args) throws Exception &#123; ConfigurableApplicationContext cac = SpringApplication.run(TestQuartzApplication.class, args); String[] names = cac.getBeanDefinitionNames(); Arrays.asList(names).forEach(name -&gt; System.out.println(name));//打印bean 可以看到helloService在倒数3 &#125;&#125; . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.4.2.RELEASE)org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorytestQuartzApplicationorg.springframework.boot.autoconfigure.internalCachingMetadataReaderFactoryorg.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessororg.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessorhelloServiceredisConfigjedis 那么现在的任务就是把，这个上下文对象防盗JobDetil的map中，2.2.1的区别来了，不在是一起new的jobDetail了,由JobBuilder和TriggerBuilder构建1234567891011121314151617@SpringBootApplication@EnableSchedulingpublic class TestQuartzApplication &#123; public static void main(String[] args) throws Exception &#123; ConfigurableApplicationContext cac = SpringApplication.run(TestQuartzApplication.class, args); String[] names = cac.getBeanDefinitionNames(); Arrays.asList(names).forEach(name -&gt; System.out.println(name));//打印bean SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); JobDetail jobDetail = JobBuilder.newJob(ScheduledTasks.class).withIdentity(&quot;testkey&quot;, &quot;testvalue&quot;).withDescription(&quot;一个测试的类&quot;).build(); jobDetail.getJobDataMap().put(&quot;ConfigurableApplicationContext&quot;,cac);//重点是这句话 Trigger trigger = TriggerBuilder.newTrigger().startNow().withSchedule(CronScheduleBuilder.cronSchedule(&quot;0/1 * * * * ?&quot;)).startNow().build(); scheduler.scheduleJob(jobDetail,trigger); scheduler.start(); &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://lxchinesszz.gitee.io/chinesszz/categories/Spring-Boot/"}],"tags":[{"name":"Spring整合Quartz","slug":"Spring整合Quartz","permalink":"http://lxchinesszz.gitee.io/chinesszz/tags/Spring整合Quartz/"}],"keywords":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://lxchinesszz.gitee.io/chinesszz/categories/Spring-Boot/"}]},{"title":"Spring Cloud初步理解","slug":"Spring Cloud初步理解","date":"2018-04-11T09:34:58.344Z","updated":"2018-04-11T09:34:58.345Z","comments":true,"path":"2018/04/11/Spring Cloud初步理解/","link":"","permalink":"http://lxchinesszz.gitee.io/chinesszz/2018/04/11/Spring Cloud初步理解/","excerpt":"","text":"Ribbon实现负载均衡 关键字：Feign、Ribbon、eureka、负载均衡 大致：步骤，启动eureka服务(注册中心) 使用Spring Cloud Netflix中的Eureka实现服务注册中心，以及服务注册发现； 将service(port:2222,port:2223)注册到eureka服务中 使用Ribbon代理去访问service 会实现负载均衡 服务间通过Ribbon或Feign实现服务的消费以及均衡负载 通过Spring Cloud Config实现应用多环境的外部化配置及版本管理 使得服务集群更为健壮，使用Hystrix熔断机制避免微服务架构中个别服务出现异常引起的故障蔓延 引入断路器 Rabbion中引入Hystrix 123456789101112@Servicepublic class ComputeService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = &quot;addServiceFallback&quot;) public String addService() &#123; return restTemplate.getForEntity(&quot;http://COMPUTE-SERVICE/add?a=10&amp;b=20&quot;, String.class).getBody(); &#125; public String addServiceFallback() &#123; return &quot;error&quot;; &#125;&#125;","categories":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://lxchinesszz.gitee.io/chinesszz/categories/Spring-Cloud/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://lxchinesszz.gitee.io/chinesszz/tags/Spring-Cloud/"}],"keywords":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://lxchinesszz.gitee.io/chinesszz/categories/Spring-Cloud/"}]},{"title":"HEXO之博客搭建","slug":"HEXO之博客搭建","date":"2018-04-11T03:49:42.000Z","updated":"2018-04-11T13:14:19.452Z","comments":false,"path":"2018/04/11/HEXO之博客搭建/","link":"","permalink":"http://lxchinesszz.gitee.io/chinesszz/2018/04/11/HEXO之博客搭建/","excerpt":"","text":"HEXO 安装hexo博客工具1npm install -g hexo-cli 初始化目录1hexo init 生成静态页面1hexo g 清理缓存1hexo clean 推送到服务器推送时候要先: npm install hexo-deployer-git –save安装依赖 修改 123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://lxchinesszz.gitee.io/chinesszz/ 访问地址root: /chinesszz 访问项目permalink: :year/:month/:day/:title/permalink_defaults: 1hexo d 本地服务预览1hexo s 查看1浏览器: http://127.0.0.1:4000/ 绑定github 修改配置项目根目录_config.yml 文件，修改deploy的值然后保存 1234deploy: type: git repo: https://gitee.com/lxchinesszz/chinesszz.git branch: 分支 在oschina中点击服务,启动pages静态访问","categories":[{"name":"杂记","slug":"杂记","permalink":"http://lxchinesszz.gitee.io/chinesszz/categories/杂记/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://lxchinesszz.gitee.io/chinesszz/tags/博客搭建/"}],"keywords":[{"name":"杂记","slug":"杂记","permalink":"http://lxchinesszz.gitee.io/chinesszz/categories/杂记/"}]},{"title":"me","slug":"me","date":"2016-03-11T15:37:26.000Z","updated":"2018-04-12T01:32:27.193Z","comments":true,"path":"2016/03/11/me/","link":"","permalink":"http://lxchinesszz.gitee.io/chinesszz/2016/03/11/me/","excerpt":"","text":"个人信息笔名: chinesszz , 网名: X , 非著名码农。生于1993年，籍贯河南，现居上海。电子商务专业,专注于基础架构和rpc通信框架研发。目前就职于某互联网软件服务公司 专注于企业微服务架构研究及开源框架底层源码研究 熟练运用各种流行的JavaEE技术进行组合式架构设计与开发。业余时间研究并发编程，中间件，异地多活，Spring Cloud，Netty等开源项目，以及软件架构设计，程序性能优化，JVM，高并发等！ 个人爱好 热爱技术,相信技术改变生活.喜欢阅读优秀框架源码,学习其设计模式,及编程技巧 热爱编程,熟练掌握Java,Python等主流编程语言及服务器Linux Bash脚本编程, 具有良好的笔记习惯, 具有快速学习的能力 喜欢记笔记,记录分享传播工作中学习到的知识,分享给同样热爱技术的人儿 宗旨本博客主要分享小编在日常工作遇到的实际问题和学习中读过的好文。希望通过博客文章,将知识分享给大家,我认为在企业应用架构实践中非常实用的干货内容。 意见反馈若本号内容有做得不到位的地方（比如：涉及版权或其他问题），请及时联系我进行整改。 联系方式邮箱: lxchinesszz@163.com 微信&amp;头条","categories":[{"name":"about","slug":"about","permalink":"http://lxchinesszz.gitee.io/chinesszz/categories/about/"}],"tags":[],"keywords":[{"name":"about","slug":"about","permalink":"http://lxchinesszz.gitee.io/chinesszz/categories/about/"}]},{"title":"Git常用命令","slug":"GIt命令","date":"2015-01-11T03:49:42.000Z","updated":"2018-04-11T09:33:42.145Z","comments":true,"path":"2015/01/11/GIt命令/","link":"","permalink":"http://lxchinesszz.gitee.io/chinesszz/2015/01/11/GIt命令/","excerpt":"","text":"查看配置文件 1git config --list 本地项目添加到github 12345678910111213git init 初始化git add ./ 进行跟踪git commit -m &apos;&apos; 提交本地#根据github仓库git remote add origin https:liuxin..#如果上面操作失败说明已经绑定了一个，就删除之前的git remote rm origin#推到远程仓库git push -u origin master 查看最近提交信息 1git log 添加并提交git commit -am ‘message’相当于添加跟踪并提交 12git commit -am &quot;some str&quot;git push 回退到上一次提交的状态git revert HEAD1git revert HEAD 回退到某个版本git reset 057d 12回退到某个版本 git reset 830bc084264841... 查看当前分支git branch123KK-MINI:svc_shenghuojiaofei liuxin$ git branch develop* master 创建分支git branch feature12345KK-MINI:svc_shenghuojiaofei liuxin$ git branch featureKK-MINI:svc_shenghuojiaofei liuxin$ git branch develop feature* master 切换分支12345678KK-MINI:svc_shenghuojiaofei liuxin$ git checkout featureM .gitignoreM src/main/resource/application.propertiesSwitched to branch &apos;feature&apos;KK-MINI:svc_shenghuojiaofei liuxin$ git branch develop* feature master 提交到最新分支 12345KK-MINI:svc_shenghuojiaofei liuxin$ git push -u origin featureTotal 0 (delta 0), reused 0 (delta 0)To https://github.com/kpboluome/svc_shenghuojiaofei.git * [new branch] feature -&gt; featureBranch feature set up to track remote branch feature from origin. 删除远程分支 git push origin --delete testfenzhi 删除本地分支 git branch -D stg 同步feature分支到master分支 git checkout master git merge feature git push origin master 回退所有内容到上一个版本 1git reset HEAD^ 回退a.py这个文件的版本到上一个版本 1git reset HEAD^ a.py ` 拉取远程分支到本地分支可以把远程某各分支拉去到本地的branchname下，如果没有branchname，则会在本地新建branchname git fetch origin branchname:branchname","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://lxchinesszz.gitee.io/chinesszz/tags/Git/"}],"keywords":[]}]}